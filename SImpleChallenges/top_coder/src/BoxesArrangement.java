import java.util.*;
import java.util.regex.*;
import java.text.*;
import java.math.*;


public class BoxesArrangement
{
    class S implements Comparable<S>{
        String ss;int p;
        S(String h,int v)
        {
            ss=h;p=v;
        }

        @Override
        public int compareTo(S o) {
            if(ss.compareTo(o.ss)==0)
                if(p==o.p)
                    return 0;
                else
                    return p-o.p;
            else
                return ss.compareTo(o.ss); //To change body of implemented methods use File | Settings | File Templates.
        }
    }
    int N; TreeMap<S,Integer> t;
    int res;

    public int maxUntouched(String boxes)
	{



        N=boxes.length();   t=new TreeMap<S, Integer>();
        res=solve("",0);
        return res;

	}

    private int solve(String s,int p)
    {
        if(t.containsKey(new S(s,p)))
        {
            return t.get(new S(s,p));
        }
        int l=s.length();
        if(p==N)
            return 1;
        long res=0;
        if(s.equals("AB"))
        {
            res=solve("BA",p+1)+ solve("BB",p+1)  ;
        }
        else if(s.equals("BC"))
        {
            res=solve("CB",p+1)+ solve("CC",p+1)  ;
        }
        else if(s.equals("AC"))
        {
            res=solve("CA",p+1)+ solve("CC",p+1)  ;
        }
        else if(s.equals("CA"))
        {
            res=solve("AC",p+1)+ solve("AA",p+1)  ;
        }
        else if(s.equals("CB"))
        {
            res=solve("BC",p+1)+ solve("BB",p+1)  ;
        }
        else if(s.equals("BA"))
        {
            res=solve("AB",p+1)+ solve("AA",p+1)  ;
        }

        else if(l==0 ||l==1)
        {
            res=solve(s+"A",p+1)+solve(s+"B",p+1)+solve(s+"C",p+1);
        }

        else{
            res=solve(s.substring(1)+"A",p+1)+solve(s.substring(1)+"B",p+1)+solve(s.substring(1)+"C",p+1);
        }
        //t.put(new S(s,p),res);
       // return res;
        return 0;
    }



	
	// BEGIN KAWIGIEDIT TESTING
	// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
	private static boolean KawigiEdit_RunTest(int testNum, String p0, boolean hasAnswer, int p1) {
		System.out.print("Test " + testNum + ": [" + "\"" + p0 + "\"");
		System.out.println("]");
		BoxesArrangement obj;
		int answer;
		obj = new BoxesArrangement();
		long startTime = System.currentTimeMillis();
		answer = obj.maxUntouched(p0);
		long endTime = System.currentTimeMillis();
		boolean res;
		res = true;
		System.out.println("Time: " + (endTime - startTime) / 1000.0 + " seconds");
		if (hasAnswer) {
			System.out.println("Desired answer:");
			System.out.println("\t" + p1);
		}
		System.out.println("Your answer:");
		System.out.println("\t" + answer);
		if (hasAnswer) {
			res = answer == p1;
		}
		if (!res) {
			System.out.println("DOESN'T MATCH!!!!");
		} else if ((endTime - startTime) / 1000.0 >= 2) {
			System.out.println("FAIL the timeout");
			res = false;
		} else if (hasAnswer) {
			System.out.println("Match :-)");
		} else {
			System.out.println("OK, but is it right?");
		}
		System.out.println("");
		return res;
	}
	public static void main(String[] args) {
		boolean all_right;
		all_right = true;
		
		String p0;
		int p1;
		
		// ----- test 0 -----
		p0 = "AAABBBCCC";
		p1 = 6;
		all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
		// ------------------
		
		// ----- test 1 -----
		p0 = "AAAAAAAACBB";
		p1 = 7;
		all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
		// ------------------
		
		// ----- test 2 -----
		p0 = "CCCCCB";
		p1 = -1;
		all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
		// ------------------
		
		// ----- test 3 -----
		p0 = "BAACAABAACAAA";
		p1 = 5;
		all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
		// ------------------
		
		// ----- test 4 -----
		p0 = "CBBABA";
		p1 = 6;
		all_right = KawigiEdit_RunTest(4, p0, true, p1) && all_right;
		// ------------------
		
		if (all_right) {
			System.out.println("You're a stud (at least on the example cases)!");
		} else {
			System.out.println("Some of the test cases had errors.");
		}
	}
	// PROBLEM STATEMENT
	// 
	// Several boxes are placed in a row. Each box is one of three colors. We want to rearrange these boxes in a such way that no three consecutive boxes are of the same color. This process should affect the fewest boxes possible. More formally, we want to achieve the desired configuration by swapping pairs of boxes, and we want to maximize the number of boxes that are never moved.
	// 
	// You will be given a String boxes which describes the colors of the boxes. Colors are given as characters 'A', 'B' and 'C' respectively. Rearrange the boxes as described above and return the maximum possible number of boxes that are never moved. Return -1 if it is not possible to achieve the desired configuration.
	// 
	// 
	// DEFINITION
	// Class:BoxesArrangement
	// Method:maxUntouched
	// Parameters:String
	// Returns:int
	// Method signature:int maxUntouched(String boxes)
	// 
	// 
	// CONSTRAINTS
	// -boxes will contain between 1 and 50 characters, inclusive. 
	// -boxes will consist of characters 'A', 'B' and 'C' only. 
	// 
	// 
	// EXAMPLES
	// 
	// 0)
	// "AAABBBCCC"
	// 
	// Returns: 6
	// 
	// The boxes could be rearranged into "ABABCBCAC".
	// 
	// 1)
	// "AAAAAAAACBB"
	// 
	// Returns: 7
	// 
	// The best rearangement is "AABAABAACAA".
	// 
	// 2)
	// "CCCCCB"
	// 
	// Returns: -1
	// 
	// 3)
	// "BAACAABAACAAA"
	// 
	// Returns: 5
	// 
	// 4)
	// "CBBABA"
	// 
	// Returns: 6
	// 
	// 
	// 
	// END KAWIGIEDIT TESTING
}
//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
