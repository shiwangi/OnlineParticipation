public class CircleMarket
{
	public int makePurchases(int[] openTime, int[] closeTime, int travelTime)
	{
        int shops=openTime.length;int time=0;int ans=0;   int flag=1;    int bought[]=new int[shops];
		for(int i=0;i<shops;i++)
        {
             if(time>=openTime[i] && time<=closeTime[i] && bought[i]!=1)
             {
                 ans++;bought[i]=1;
             }

            else if(closeTime[i]>=time+shops*travelTime)
                flag=1;
            time+=travelTime;
            if(i==shops-1 && flag==1)
            {
                i=-1;flag=0;
            }
        }
        return  ans;
	}
	
	// BEGIN KAWIGIEDIT TESTING
	// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
	private static boolean KawigiEdit_RunTest(int testNum, int[] p0, int[] p1, int p2, boolean hasAnswer, int p3) {
		System.out.print("Test " + testNum + ": [" + "{");
		for (int i = 0; p0.length > i; ++i) {
			if (i > 0) {
				System.out.print(",");
			}
			System.out.print(p0[i]);
		}
		System.out.print("}" + "," + "{");
		for (int i = 0; p1.length > i; ++i) {
			if (i > 0) {
				System.out.print(",");
			}
			System.out.print(p1[i]);
		}
		System.out.print("}" + "," + p2);
		System.out.println("]");
		CircleMarket obj;
		int answer;
		obj = new CircleMarket();
		long startTime = System.currentTimeMillis();
		answer = obj.makePurchases(p0, p1, p2);
		long endTime = System.currentTimeMillis();
		boolean res;
		res = true;
		System.out.println("Time: " + (endTime - startTime) / 1000.0 + " seconds");
		if (hasAnswer) {
			System.out.println("Desired answer:");
			System.out.println("\t" + p3);
		}
		System.out.println("Your answer:");
		System.out.println("\t" + answer);
		if (hasAnswer) {
			res = answer == p3;
		}
		if (!res) {
			System.out.println("DOESN'T MATCH!!!!");
		} else if ((endTime - startTime) / 1000.0 >= 2) {
			System.out.println("FAIL the timeout");
			res = false;
		} else if (hasAnswer) {
			System.out.println("Match :-)");
		} else {
			System.out.println("OK, but is it right?");
		}
		System.out.println("");
		return res;
	}
	public static void main(String[] args) {
		boolean all_right;
		all_right = true;
		
		int[] p0;
		int[] p1;
		int p2;
		int p3;
		
		// ----- test 0 -----
		p0 = new int[]{0,0,0};
		p1 = new int[]{100,100,100};
		p2 = 3;
		p3 = 3;
		all_right = KawigiEdit_RunTest(0, p0, p1, p2, true, p3) && all_right;
		// ------------------
		
		// ----- test 1 -----
		p0 = new int[]{45,45,0};
		p1 = new int[]{50,50,20};
		p2 = 15;
		p3 = 1;
		all_right = KawigiEdit_RunTest(1, p0, p1, p2, true, p3) && all_right;
		// ------------------
		
		// ----- test 2 -----
		p0 = new int[]{1000,1000};
		p1 = new int[]{1010,1010};
		p2 = 1;
		p3 = 2;
		all_right = KawigiEdit_RunTest(2, p0, p1, p2, true, p3) && all_right;
		// ------------------
		
		// ----- test 3 -----
		p0 = new int[]{999999,2,4};
		p1 = new int[]{1000000,22,44};
		p2 = 2;
		p3 = 2;
		all_right = KawigiEdit_RunTest(3, p0, p1, p2, true, p3) && all_right;
		// ------------------
		
		// ----- test 4 -----
		p0 = new int[]{363,237,382,232,392,3829,99999,12};
		p1 = new int[]{365,1239,2384,234,394,3831,100001,15};
		p2 = 3;
		p3 = 3;
		all_right = KawigiEdit_RunTest(4, p0, p1, p2, true, p3) && all_right;
		// ------------------
		
		if (all_right) {
			System.out.println("You're a stud (at least on the example cases)!");
		} else {
			System.out.println("Some of the test cases had errors.");
		}
	}
	// PROBLEM STATEMENT
	// You are visiting a market that is composed of many stores distributed in a circular shape. The stores are indexed from 0 to n-1 in clockwise order. You want to purchase exactly one item from each of the stores. You start at store 0 at time = 0 seconds, and will move between the stores in clockwise order. If you arrive at store i before openTime[i] or after closeTime[i], that means the store is closed and you cannot make a purchase.  If you arrive at a time between openTime[i] and closeTime[i], inclusive, and you have not yet purchased your one desired item from that store, then you must purchase it immediately (it doesn't take time to make a purchase).  In both cases, you must then proceed to the next store immediately. Traveling clockwise between two consecutive stores requires travelTime seconds. You will leave the market once it is no longer possible for you to make any new purchase.
	// 
	// Return the total number of purchases you will make.
	// 
	// DEFINITION
	// Class:CircleMarket
	// Method:makePurchases
	// Parameters:int[], int[], int
	// Returns:int
	// Method signature:int makePurchases(int[] openTime, int[] closeTime, int travelTime)
	// 
	// 
	// CONSTRAINTS
	// -openTime will contain between 2 and 50 elements, inclusive.
	// -closeTime will contain the same number of elements as openTime.
	// -travelTime will be between 1 and 1000000, inclusive.
	// -Each element of openTime will be between 0 and 999999, inclusive.
	// -Element i of closeTime will be between openTime[i]+1 and 1000000, inclusive.
	// 
	// 
	// EXAMPLES
	// 
	// 0)
	// {0, 0, 0}
	// {100, 100, 100}
	// 3
	// 
	// Returns: 3
	// 
	// 
	// 
	// 1)
	// {45, 45, 0}
	// {50, 50, 20}
	// 15
	// 
	// Returns: 1
	// 
	// The first time stores 0 and 1 are visited, they will be closed. Store 2 can only be visited after 30 seconds which is after its closing time. Store 0 will be open the next time it is visited at 45 seconds. The second time store 1 is visited the time will be 60 seconds and it will be closed.
	// 
	// 
	// 
	// 2)
	// {1000, 1000}
	// {1010, 1010}
	// 1
	// 
	// Returns: 2
	// 
	// The stores will be closed for the first 500 visits. The 501-th time you visit each of the stores, they will finally be open.
	// 
	// 3)
	// {999999, 2, 4}
	// {1000000, 22, 44}
	// 2
	// 
	// Returns: 2
	// 
	// 
	// 
	// 4)
	// {363, 237, 382, 232, 392, 3829, 99999, 12}
	// {365, 1239, 2384, 234, 394, 3831, 100001, 15}
	// 3
	// 
	// Returns: 3
	// 
	// 
	// 
	// END KAWIGIEDIT TESTING
}
//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
