import java.util.*;
import java.util.regex.*;
import java.text.*;
import java.math.*;


public class CactusCount
{
    class Edges implements Comparable<Edges>{
        int start,end;
        Edges(int s,int e)
        {
            start=s;
            end=e;
        }

        @Override
        public int compareTo(Edges o) {
          if((start-o.start)==0 && (end-o.end)==0)
              return 0;
                return 1;//To change body of implemented methods use File | Settings | File Templates.
        }
    }
    ArrayList<Integer> a[];
    TreeMap<Edges,Integer> map;
	public int countCacti(int n, String[] edges)
	{
		a=new ArrayList[n+1];

        for(int i=0;i<n+1;i++)
        {
            a[i]=new ArrayList<Integer>();
        }
        String s="";
        for (int i=0;i<edges.length;i++)
        {
            s+=edges[i];
        }
        if(!s.equals("")) {
            String tokens[]=s.split(",");
        int from,to;
        for(int i=0;i<tokens.length;i++)
        {
            String t[]=tokens[i].split(" ");
            from=Integer.parseInt(t[0])-1;
            to=Integer.parseInt(t[1])-1;
            a[from].add(to);
            a[to].add(from);
        }
        }
        int linker;
        int grouped[]=new int[n];
        int count;
        int vertex;

        for(int i=0;i<n;i++)
        {
            if(grouped[i]==0)
            {
            for(int j=0;j<a[i].size();j++)
            {
                count=0;
                map=new TreeMap<Edges, Integer>();
                   vertex=a[i].get(j);
                    map.put(new Edges(i,j),1);
                    map.put(new Edges(j,i),1);
                   for(int k=0;k<a[i].size();k++)
                   {
                       if(j!=k)
                       {
                           //perform a dfs from node a[i].get(k) and you get back vertex then count++;
                           Stack<Integer> stack=new Stack<Integer>();
                           stack.push(a[i].get(k));
                           outer: while(!stack.isEmpty())
                           {
                               linker=stack.pop();
                               if(linker==vertex)
                               {
                                   count++;
                                   continue outer;
                               }
                               for(int f=0;f<a[linker].size();f++)
                               {
                                   if((!map.containsKey(new Edges(linker,a[linker].get(f))))){
                                       map.put(new Edges(linker,a[linker].get(f)),1);
                                       map.put(new Edges(a[linker].get(f),linker),1);
                                       if( grouped[a[linker].get(f)]==0){
                                           grouped[a[linker].get(f)]=1;
                                           stack.push(a[linker].get(f));
                                       }
                                   }
                   }
                           }
                       }
                   }
            }}}
        return 0;
	}
	
	// BEGIN KAWIGIEDIT TESTING
	// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
	private static boolean KawigiEdit_RunTest(int testNum, int p0, String[] p1, boolean hasAnswer, int p2) {
		System.out.print("Test " + testNum + ": [" + p0 + "," + "{");
		for (int i = 0; p1.length > i; ++i) {
			if (i > 0) {
				System.out.print(",");
			}
			System.out.print("\"" + p1[i] + "\"");
		}
		System.out.print("}");
		System.out.println("]");
		CactusCount obj;
		int answer;
		obj = new CactusCount();
		long startTime = System.currentTimeMillis();
		answer = obj.countCacti(p0, p1);
		long endTime = System.currentTimeMillis();
		boolean res;
		res = true;
		System.out.println("Time: " + (endTime - startTime) / 1000.0 + " seconds");
		if (hasAnswer) {
			System.out.println("Desired answer:");
			System.out.println("\t" + p2);
		}
		System.out.println("Your answer:");
		System.out.println("\t" + answer);
		if (hasAnswer) {
			res = answer == p2;
		}
		if (!res) {
			System.out.println("DOESN'T MATCH!!!!");
		} else if ((endTime - startTime) / 1000.0 >= 2) {
			System.out.println("FAIL the timeout");
			res = false;
		} else if (hasAnswer) {
			System.out.println("Match :-)");
		} else {
			System.out.println("OK, but is it right?");
		}
		System.out.println("");
		return res;
	}
	public static void main(String[] args) {
		boolean all_right;
		all_right = true;
		
		int p0;
		String[] p1;
		int p2;
        // ----- test 3 -----
        p0 = 17;
        p1 = new String[]{"1 2,2 3,3 4,4 5,5 3,1 3,6 7,7 8,6 8,8 9,9 1","0,10 11,11 9,12 13,14 15,15 16,16 17,14 17,14 16"};
        p2 = 2;
        all_right = KawigiEdit_RunTest(3, p0, p1, true, p2) && all_right;
        // ------------------

        // ----- test 0 -----
		p0 = 3;
		p1 = new String[]{"1 2,1 3,2 3"};
		p2 = 1;
		all_right = KawigiEdit_RunTest(0, p0, p1, true, p2) && all_right;
		// ------------------
		
		// ----- test 1 -----
		p0 = 10;
		p1 = new String[]{};
		p2 = 10;
		all_right = KawigiEdit_RunTest(1, p0, p1, true, p2) && all_right;
		// ------------------
		
		// ----- test 2 -----
		p0 = 5;
		p1 = new String[]{"1 2,3 4,4 5"};
		p2 = 2;
		all_right = KawigiEdit_RunTest(2, p0, p1, true, p2) && all_right;
		// ------------------
		

		if (all_right) {
			System.out.println("You're a stud (at least on the example cases)!");
		} else {
			System.out.println("Some of the test cases had errors.");
		}
	}
	// PROBLEM STATEMENT
	// 
	// A vertex cactus is a connected undirected graph such that each vertex belongs to at most one simple cycle.  A simple cycle is a cycle that doesn't pass through any vertex more than once.  For example, the graph pictured below is a vertex cactus:
	// 
	// 
	// 
	// 
	// 
	// You are given an int n, the number of vertices in a graph G.  The vertices are numbered from 1 to n.  The edges in G are given in the String[] edges.  Concatenate the elements of edges to get a comma-separated list of integer pairs.  The integers in each pair are separated by a space.  The pair "i j" (quotes for clarity) means that there is an edge between vertices i and j.  Return the number of connected components of G that are vertex cacti.
	// 
	// 
	// DEFINITION
	// Class:CactusCount
	// Method:countCacti
	// Parameters:int, String[]
	// Returns:int
	// Method signature:int countCacti(int n, String[] edges)
	// 
	// 
	// NOTES
	// -A connected component of a graph G is a set of vertices such that each pair of vertices in the set is connected by a path, and no vertex outside the set is connected to any vertex within the set.
	// 
	// 
	// CONSTRAINTS
	// -n will be between 1 and 200, inclusive.
	// -edges will contain between 0 and 50 elements, inclusive.
	// -Each element of edges will contain between 1 and 50 characters, inclusive.
	// -When concatenated, edges will contain a comma separated list of integer pairs.
	// -The integers within each pair will be separated by a space.
	// -The integers within each pair will be distinct.
	// -Each integer will be between 1 and n, inclusive, with no leading zeroes.
	// -Every pair of vertices will be connected by at most one edge.
	// 
	// 
	// EXAMPLES
	// 
	// 0)
	// 3
	// {"1 2,1 3,2 3"}
	// 
	// Returns: 1
	// 
	// One cycle is a vertex cactus.
	// 
	// 1)
	// 10
	// {}
	// 
	// Returns: 10
	// 
	// Here each vertex is a component by itself. A graph with one vertex is a vertex cactus.
	// 
	// 2)
	// 5
	// {"1 2,3 4,4 5"}
	// 
	// Returns: 2
	// 
	// Both components are trees. A tree is a vertex cactus.
	// 
	// 3)
	// 17
	// {"1 2,2 3,3 4,4 5,5 3,1 3,6 7,7 8,6 8,8 9,9 1",
	//  "0,10 11,11 9,12 13,14 15,15 16,16 17,14 17,14 16"}
	// 
	// Returns: 2
	// 
	// Here are two cacti and two non-cacti. The component with vertices 1, 2, 3, 4 and 5 is not a vertex cactus because vertex 3 belongs to two cycles: 1-2-3 and 3-4-5.  The component with vertices 14, 15, 16 and 17 is not a vertex cactus either.  Vertex 14, for example, belongs to more than one cycle.
	// 
	// 
	// 
	// END KAWIGIEDIT TESTING
}
//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
