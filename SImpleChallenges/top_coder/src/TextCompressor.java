public class TextCompressor
{
	public String longestRepeat(String sourceText)
	{
		          int len=sourceText.length();int point=0;String ans="";int max=0;
        outer: for(int i=0;i<len;i++)
        {
            String s="";
            for(int j=i;j<len;j++)
            {
                 s+=sourceText.charAt(j);

                 if(sourceText.indexOf(s,j+1)==-1)
                        continue outer;
               else{
                if(max<j-i+1)
                {
                    max=j-i+1;
                    ans=s;
                }

            }
            }
        }
        return  ans;
	}
	
	// BEGIN KAWIGIEDIT TESTING
	// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
	private static boolean KawigiEdit_RunTest(int testNum, String p0, boolean hasAnswer, String p1) {
		System.out.print("Test " + testNum + ": [" + "\"" + p0 + "\"");
		System.out.println("]");
		TextCompressor obj;
		String answer;
		obj = new TextCompressor();
		long startTime = System.currentTimeMillis();
		answer = obj.longestRepeat(p0);
		long endTime = System.currentTimeMillis();
		boolean res;
		res = true;
		System.out.println("Time: " + (endTime - startTime) / 1000.0 + " seconds");
		if (hasAnswer) {
			System.out.println("Desired answer:");
			System.out.println("\t" + "\"" + p1 + "\"");
		}
		System.out.println("Your answer:");
		System.out.println("\t" + "\"" + answer + "\"");
		if (hasAnswer) {
			res = answer.equals(p1);
		}
		if (!res) {
			System.out.println("DOESN'T MATCH!!!!");
		} else if ((endTime - startTime) / 1000.0 >= 2) {
			System.out.println("FAIL the timeout");
			res = false;
		} else if (hasAnswer) {
			System.out.println("Match :-)");
		} else {
			System.out.println("OK, but is it right?");
		}
		System.out.println("");
		return res;
	}
	public static void main(String[] args) {
		boolean all_right;
		all_right = true;
		
		String p0;
		String p1;
		
		// ----- test 0 -----
		p0 = "ABCDABCFG";
		p1 = "ABC";
		all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
		// ------------------
		
		// ----- test 1 -----
		p0 = "aa";
		p1 = "a";
		all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
		// ------------------
		
		// ----- test 2 -----
		p0 = "This is a test.";
		p1 = "is ";
		all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
		// ------------------
		
		// ----- test 3 -----
		p0 = "Testing testing 1 2 3.";
		p1 = "esting ";
		all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
		// ------------------
		
		// ----- test 4 -----
		p0 = "The quick brown fox jumps over the lazy dog.";
		p1 = "he ";
		all_right = KawigiEdit_RunTest(4, p0, true, p1) && all_right;
		// ------------------
		
		if (all_right) {
			System.out.println("You're a stud (at least on the example cases)!");
		} else {
			System.out.println("Some of the test cases had errors.");
		}
	}
	// PROBLEM STATEMENT
	// Your company is working on writing a piece of software to compress a text document.  As part
	// of the software development team, you have been asked to write a function that will find the
	// longest repeated sub-string within a piece of text, such that the two chosen occurrences of the sub-string do not overlap.  Your software is case sensitive, so two sub-strings are not the same if their capitalization differs.  You have been instructed that, in a case where more than one such sub-string is the longest, the one that occurs earliest in the source string should be chosen.
	// For instance, given the string "ABCDABCFG", the longest repeated sub-string is "ABC".  In the
	// string "ABABA", both "AB" and "BA" are repeated substrings, however, we choose "AB", since it occurs earlier.  (Even though "ABA" appears twice as a
	// sub-string, the two occurrences overlaps, so that can not be used.)
	// You are given a String sourceText.  You are to return a String
	// that is the longest repeated sub-string.  If more than one substring of equal maximum length is repeated, return the one that occurs first in the string.  If no sub-string repeats itself, return "".
	// 
	// DEFINITION
	// Class:TextCompressor
	// Method:longestRepeat
	// Parameters:String
	// Returns:String
	// Method signature:String longestRepeat(String sourceText)
	// 
	// 
	// CONSTRAINTS
	// -sourceText will contain between 1 and 50 characters, inclusive.
	// -Each character of sourceText will be 'A'-'Z', 'a'-'z', '0'-'9', '.' or ' '.
	// 
	// 
	// EXAMPLES
	// 
	// 0)
	// "ABCDABCFG"
	// 
	// Returns: "ABC"
	// 
	// The first example from the problem statement.
	// 
	// 1)
	// "ABABA"
	// 
	// Returns: "AB"
	// 
	// The second example from the problem statement.  Notice in particular that the two occurrences cannot overlap.  Also, notice that "BA" is repeated as well, but "AB" occurs earlier in the string.
	// 
	// 2)
	// "This is a test."
	// 
	// Returns: "is "
	// 
	// Notice here that the longest repeated substring is not restricted to just being a complete word, or part of a word, and may include spaces.
	// 
	// 3)
	// "Testing testing 1 2 3."
	// 
	// Returns: "esting "
	// 
	// Notice here that although the word "testing" appears twice, the capitalization is different, so it's not actually a repeated substring.
	// 
	// 4)
	// "The quick brown fox jumps over the lazy dog."
	// 
	// Returns: "he "
	// 
	// END KAWIGIEDIT TESTING
}
//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
