import java.util.*;
import java.util.regex.*;
import java.text.*;
import java.math.*;


public class EventOrder
{
    int dp[][];
	public int getCount(int longEvents, int instantEvents)
	{
        dp=new int[longEvents+1][longEvents+1];
        for(int i=0;i<=longEvents;i++)
        Arrays.fill(dp[i],-1);
		 int res=solve(longEvents,0);
                  int elements=(longEvents*2);
        int gaps=longEvents*2+1;
        int fac=calc_fac(elements,gaps,instantEvents);
         return  ((res*(fac% 1000000009))% 1000000009);
	}

    private int calc_fac(int ele,int gaps,int d) {
        int res=1;
        if(d==0)
            return res;
        res=ele*calc_fac(ele,gaps,d-1)% 1000000009+gaps*calc_fac(ele+1,gaps+1,d-1)% 1000000009;

        return res;
    }

    private int solve(int longEvents, int started) {
        if(dp[longEvents][started]!=-1)
            return dp[longEvents][started];
        int res=0;
        if(longEvents==0 && started==0 )
            return 1;
        if(started==0)
        {
            for(int i=1;i<=longEvents;i++)
            res+=C(longEvents,i)*solve(longEvents-i, started+i) % 1000000009;
        }
        else if(longEvents==0)
        {
            for(int i=1;i<=started;i++)
            res+=C(started,i)*solve(longEvents, started-i)% 1000000009;
        }
        else{
            for(int i=0;i<=longEvents;i++) {
                for (int j = 0; j <= started; j++) {
                    if(i==0 && j==0)
                        continue;
                    if(i==0)
                        res+=C(started,j)*solve(longEvents, started-j)% 1000000009;
                    else if(j==0)
                        res+=C(longEvents,i)*solve(longEvents-i, started+i) % 1000000009;
                    else
                    res += (C(longEvents, i)* C(started, j)  *  solve(longEvents - i, started + i-j) % 1000000009) ;
                }
            }
        }
        dp[longEvents][started]=res;
        return res;
    }


    private int C(int longEvents, int r) {
        int i, j;
        if(r==0)
            return longEvents;
        if(r>longEvents/2)
            r=longEvents-r;
                 int [][]triangle=new int[longEvents+1][r+1];

        triangle[0][0] = 1; // C(0, 0) = 1

        for(i = 1; i <=longEvents; i++) {
            triangle[i][0] = 1; // C(i, 0) = 1
            for(j = 1; j <= r && j <= i; j++) {
                triangle[i][j] = triangle[i - 1][j - 1] + triangle[i - 1][j];
                if(i==longEvents && j==r)
                    break;
            }
        }
        return triangle[longEvents][r];
    }

    // BEGIN KAWIGIEDIT TESTING
	// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
	private static boolean KawigiEdit_RunTest(int testNum, int p0, int p1, boolean hasAnswer, int p2) {
		System.out.print("Test " + testNum + ": [" + p0 + "," + p1);
		System.out.println("]");
		EventOrder obj;
		int answer;
		obj = new EventOrder();
		long startTime = System.currentTimeMillis();
		answer = obj.getCount(p0, p1);
		long endTime = System.currentTimeMillis();
		boolean res;
		res = true;
		System.out.println("Time: " + (endTime - startTime) / 1000.0 + " seconds");
		if (hasAnswer) {
			System.out.println("Desired answer:");
			System.out.println("\t" + p2);
		}
		System.out.println("Your answer:");
		System.out.println("\t" + answer);
		if (hasAnswer) {
			res = answer == p2;
		}
		if (!res) {
			System.out.println("DOESN'T MATCH!!!!");
		} else if ((endTime - startTime) / 1000.0 >= 2) {
			System.out.println("FAIL the timeout");
			res = false;
		} else if (hasAnswer) {
			System.out.println("Match :-)");
		} else {
			System.out.println("OK, but is it right?");
		}
		System.out.println("");
		return res;
	}
	public static void main(String[] args) {
		boolean all_right;
		all_right = true;
		
		int p0;
		int p1;
		int p2;
		
		// ----- test 0 -----
		p0 = 1000;
		p1 = 1000;
		p2 = 3;
		all_right = KawigiEdit_RunTest(0, p0, p1, true, p2) && all_right;
		// ------------------
		
		// ----- test 1 -----
		p0 = 1;
		p1 = 1;
		p2 = 5;
		all_right = KawigiEdit_RunTest(1, p0, p1, true, p2) && all_right;
		// ------------------
		
		// ----- test 2 -----
		p0 = 2;
		p1 = 0;
		p2 = 13;
		all_right = KawigiEdit_RunTest(2, p0, p1, true, p2) && all_right;
		// ------------------
		
		// ----- test 3 -----
		p0 = 0;
		p1 = 4;
		p2 = 75;
		all_right = KawigiEdit_RunTest(3, p0, p1, true, p2) && all_right;
		// ------------------
		
		if (all_right) {
			System.out.println("You're a stud (at least on the example cases)!");
		} else {
			System.out.println("Some of the test cases had errors.");
		}
	}
	// PROBLEM STATEMENT
	// 
	// We are given a set of events. Each of the events is unique. Some events are long, each of these may take any positive amount of time. Different long events may take different amounts of time. The other events are instant, each of these happens instantly at some moment in time.
	// 
	// 
	// We want to arrange the events into a schedule. We do not care about exact times when the events take place, we only consider their relative order. For example, given long events A and B and an instant event C, one of the possible schedules looks as follows:
	// 
	// 
	// Event A starts.
	// Event B starts.
	// Event B ends and at the same time event C happens.
	// Event A ends.
	// 
	// 
	// 
	// You are given an int longEvents and an int instantEvents. 
	// Let X be the total number of distinct schedules with exactly longEvents long and instantEvents instant events.
	// Your method should return the value (X modulo 1,000,000,009).
	// 
	// 
	// DEFINITION
	// Class:EventOrder
	// Method:getCount
	// Parameters:int, int
	// Returns:int
	// Method signature:int getCount(int longEvents, int instantEvents)
	// 
	// 
	// CONSTRAINTS
	// -longEvents will be between 0 and 1000, inclusive.
	// -instantEvents will be between 0 and 1000, inclusive.
	// -At least one of longEvents and instantEvents will be positive.
	// 
	// 
	// EXAMPLES
	// 
	// 0)
	// 0
	// 2
	// 
	// Returns: 3
	// 
	// If we label the events A and B, then the three schedules are "A before B", "both at the same time", and "A after B".
	// 
	// 1)
	// 1
	// 1
	// 
	// Returns: 5
	// 
	// If we label the long event A and the instant event B, then the five schedules are "B before A starts", "B when A starts", "B during A", "B when A ends", and "B after A".
	// 
	// 2)
	// 2
	// 0
	// 
	// Returns: 13
	// 
	// There are 6 schedules in which no two endpoints of events coincide, 2 schedules when one event starts when the other one ends, 2 schedules with the same beginning and different end, 2 with same end and different beginning, and 1 when the events start and end at the same time.
	// 
	// 3)
	// 0
	// 4
	// 
	// Returns: 75
	// 
	// 
	// 
	// END KAWIGIEDIT TESTING
}
//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
